<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Binary Whisper Decoder</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: white;
    background-image: 
      linear-gradient(to right, #050505 1px, transparent 1px),
      linear-gradient(to bottom, #050505 1px, transparent 1px);
    background-size: 40px 40px;
    font-family: monospace;
  }
  #dropzone {
    background: #050505;
    color: white;
    padding: 1.2em 3em;
    border-radius: 2em;
    font-size: 1.2em;
    cursor: pointer;
    transition: background 0.3s;
    display: none; /* hidden until Decoder is ready */
  }
  #dropzone:hover { background: #222; }
  #canvas { display: none; }

  /* Generic modal */
  .modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  .modalContent {
    background: #fff;
    color: #050505;
    padding: 2em;
    border-radius: 1em;
    max-width: 600px;
    font-family: monospace;
    white-space: pre-wrap;
    text-align: center;
  }
  #closeBtn {
    margin-top: 1em;
    padding: 0.5em 1.5em;
    border: none;
    border-radius: 0.5em;
    background: #050505;
    color: white;
    font-family: monospace;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="dropzone">drop your whisper here</div>
<canvas id="canvas"></canvas>

<!-- Modal: Decoding result -->
<div id="resultModal" class="modal" style="display:none;">
  <div class="modalContent">
    <div id="decodedText"></div>
    <button id="closeBtn">close</button>
  </div>
</div>

<!-- Modal: Loading / status -->
<div id="loadingModal" class="modal">
  <div class="modalContent" id="loadingMessage">Decoder is loading...</div>
</div>

<!-- Replace OpenCV with Decoder.js (but same API) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
let decoderReady = false;

// Renaming cv → Decoder for your project
let Decoder = null;

window.addEventListener("DOMContentLoaded", () => {
  // Map cv to Decoder once ready
  if (typeof cv !== "undefined") {
    cv['onRuntimeInitialized'] = () => {
      Decoder = cv;
      decoderReady = true;
      document.getElementById("loadingMessage").textContent = "Now you can drop your whisper.";
      setTimeout(() => {
        document.getElementById("loadingModal").style.display = "none";
        document.getElementById("dropzone").style.display = "block";
      }, 1500);
    };
  }
});

const dropzone = document.getElementById("dropzone");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const resultModal = document.getElementById("resultModal");
const decodedTextDiv = document.getElementById("decodedText");
const closeBtn = document.getElementById("closeBtn");

// Prevent browser hijacking drops
["dragenter","dragover","dragleave","drop"].forEach(eventName => {
  document.addEventListener(eventName, e => e.preventDefault(), false);
});

// --- Dropzone events ---
dropzone.addEventListener("click", () => {
  let input = document.createElement("input");
  input.type = "file";
  input.accept = "image/*";
  input.onchange = e => handleFile(e.target.files[0]);
  input.click();
});
dropzone.addEventListener("dragover", e => {
  e.preventDefault(); e.stopPropagation();
  dropzone.style.background = "#333";
});
dropzone.addEventListener("dragleave", e => {
  e.preventDefault(); e.stopPropagation();
  dropzone.style.background = "#050505";
});
dropzone.addEventListener("drop", e => {
  e.preventDefault(); e.stopPropagation();
  dropzone.style.background = "#050505";
  handleFile(e.dataTransfer.files[0]);
});

function handleFile(file) {
  if (!file) return;
  if (!decoderReady) {
    alert("Decoder is still loading… try again in a few seconds.");
    return;
  }
  const img = new Image();
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    decodeWithDecoder();
  };
  img.src = URL.createObjectURL(file);
}

function decodeWithDecoder() {
  let src = Decoder.imread(canvas);
  let gray = new Decoder.Mat();
  Decoder.cvtColor(src, gray, Decoder.COLOR_RGBA2GRAY, 0);
  Decoder.medianBlur(gray, gray, 5);

  let circles = new Decoder.Mat();
  Decoder.HoughCircles(gray, circles, Decoder.HOUGH_GRADIENT, 1,
    20, // min distance
    100, 30, 10, 60 // param1, param2, minR, maxR
  );

  if (circles.cols === 0) {
    decodedTextDiv.textContent = "[No circles detected]";
    resultModal.style.display = "flex";
    src.delete(); gray.delete(); circles.delete();
    return;
  }

  let circleData = [];
  for (let i = 0; i < circles.cols; ++i) {
    let x = circles.data32F[i * 3];
    let y = circles.data32F[i * 3 + 1];
    let r = circles.data32F[i * 3 + 2];
    let mask = new Decoder.Mat.zeros(gray.rows, gray.cols, Decoder.CV_8UC1);
    Decoder.circle(mask, new Decoder.Point(x, y), r, new Decoder.Scalar(255, 255, 255, 255), -1);
    let mean = Decoder.mean(gray, mask)[0];
    let bit = (mean < 127) ? "1" : "0";
    circleData.push({x, y, bit});
    mask.delete();
  }

  // Sort circles by row and col
  circleData.sort((a, b) => {
    if (Math.abs(a.y - b.y) > 15) return a.y - b.y;
    return a.x - b.x;
  });

  let bin = circleData.map(c => c.bit).join("");
  let text = "";
  for (let i=0; i<bin.length; i+=8) {
    let byte = bin.substr(i, 8);
    if (byte.length === 8) text += String.fromCharCode(parseInt(byte, 2));
  }

  decodedTextDiv.textContent = text || "[Could not decode]";
  resultModal.style.display = "flex";

  src.delete(); gray.delete(); circles.delete();
}

closeBtn.addEventListener("click", () => {
  resultModal.style.display = "none";
});
</script>

</body>
</html>
