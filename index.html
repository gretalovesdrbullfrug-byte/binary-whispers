<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Binary Whisper Decoder</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: white;
    background-image: 
      linear-gradient(to right, #050505 1px, transparent 1px),
      linear-gradient(to bottom, #050505 1px, transparent 1px);
    background-size: 40px 40px;
    font-family: monospace;
  }
  #dropzone {
    background: #050505;
    color: white;
    padding: 1.2em 3em;
    border-radius: 2em;
    font-size: 1.2em;
    cursor: pointer;
    transition: background 0.3s;
  }
  #dropzone:hover { background: #222; }
  #canvas { display: none; }

  /* Modal popup */
  #modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
  }
  #modalContent {
    background: #fff;
    color: #050505;
    padding: 2em;
    border-radius: 1em;
    max-width: 600px;
    font-family: monospace;
    white-space: pre-wrap;
    text-align: center;
  }
  #closeBtn {
    margin-top: 1em;
    padding: 0.5em 1.5em;
    border: none;
    border-radius: 0.5em;
    background: #050505;
    color: white;
    font-family: monospace;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="dropzone">drop your whisper here</div>
<canvas id="canvas"></canvas>

<!-- Modal -->
<div id="modal">
  <div id="modalContent">
    <div id="decodedText"></div>
    <button id="closeBtn">close</button>
  </div>
</div>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const dropzone = document.getElementById("dropzone");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const modal = document.getElementById("modal");
const decodedTextDiv = document.getElementById("decodedText");
const closeBtn = document.getElementById("closeBtn");

let cvReady = false;
cv['onRuntimeInitialized'] = () => {
  cvReady = true;
  console.log("OpenCV.js loaded and ready.");
};

// ðŸš« Prevent default browser behavior (image replacing page)
window.addEventListener("dragover", e => e.preventDefault());
window.addEventListener("drop", e => e.preventDefault());

// --- Upload handlers ---
dropzone.addEventListener("click", () => {
  let input = document.createElement("input");
  input.type = "file";
  input.accept = "image/*";
  input.onchange = e => handleFile(e.target.files[0]);
  input.click();
});

dropzone.addEventListener("dragover", e => { 
  e.preventDefault(); 
  dropzone.style.background = "#333"; 
});
dropzone.addEventListener("dragleave", e => { 
  dropzone.style.background = "#050505"; 
});
dropzone.addEventListener("drop", e => {
  e.preventDefault();
  dropzone.style.background = "#050505";
  handleFile(e.dataTransfer.files[0]);
});

function handleFile(file) {
  if (!file) return;
  if (!cvReady) {
    alert("OpenCV.js is still loading... try again in a few seconds.");
    return;
  }
  const img = new Image();
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    decodeWithOpenCV();
  };
  img.src = URL.createObjectURL(file);
}

function decodeWithOpenCV() {
  let src = cv.imread(canvas);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
  cv.medianBlur(gray, gray, 5);

  let circles = new cv.Mat();
  cv.HoughCircles(gray, circles, cv.HOUGH_GRADIENT, 1,
    20, // min distance
    100, 30, 10, 60 // param1, param2, minR, maxR
  );

  if (circles.cols === 0) {
    decodedTextDiv.textContent = "[No circles detected]";
    modal.style.display = "flex";
    src.delete(); gray.delete(); circles.delete();
    return;
  }

  let circleData = [];
  for (let i = 0; i < circles.cols; ++i) {
    let x = circles.data32F[i * 3];
    let y = circles.data32F[i * 3 + 1];
    let r = circles.data32F[i * 3 + 2];
    let mask = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8UC1);
    cv.circle(mask, new cv.Point(x, y), r, new cv.Scalar(255, 255, 255, 255), -1);
    let mean = cv.mean(gray, mask)[0];
    let bit = (mean < 127) ? "1" : "0";
    circleData.push({x, y, bit});
    mask.delete();
  }

  circleData.sort((a, b) => {
    if (Math.abs(a.y - b.y) > 15) return a.y - b.y;
    return a.x - b.x;
  });

  let bin = circleData.map(c => c.bit).join("");

  let text = "";
  for (let i=0; i<bin.length; i+=8) {
    let byte = bin.substr(i, 8);
    if (byte.length === 8) text += String.fromCharCode(parseInt(byte, 2));
  }

  decodedTextDiv.textContent = text || "[Could not decode]";
  modal.style.display = "flex";

  src.delete(); gray.delete(); circles.delete();
}

closeBtn.addEventListener("click", () => { modal.style.display = "none"; });
</script>

</body>
</html>
