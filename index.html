<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Binary Whisper Decoder — CellNumber (UI clássico)</title>
  <style>
    :root {
      --bg: #ffffff;
      --grid: #050505;
      --accent: #0066cc;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--bg);
      background-image:
        linear-gradient(to right, var(--grid) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
      background-size: 40px 40px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    #header { position: fixed; top: 12px; left: 12px; right: 12px; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    #title { font-weight: 700; padding: 6px 10px; border-radius: 10px; background: rgba(0,0,0,0.06); }
    #controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px solid #ddd; background: #fff; display: inline-flex; align-items: center; gap: 6px; }
    .pill input[type="number"] { width: 72px; }
    .pill input[type="range"] { width: 160px; }
    .btn { cursor: pointer; user-select: none; }

    #dropzone {
      background: #050505; color: white; padding: 1.2em 3em; border-radius: 2em; font-size: 1.2em; cursor: pointer;
      transition: background 0.25s; text-align: center; box-shadow: 0 10px 24px rgba(0,0,0,0.15);
    }
    #dropzone:hover { background: #222; }
    #canvas { display: none; }

    #modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
    #modalContent { background: #fff; color: #050505; padding: 1.25em 1.25em 1em; border-radius: 14px; max-width: 90vw; max-height: 85vh; overflow-y: auto; font-family: inherit; }
    .result-section { margin-bottom: 1em; padding: 1em; border: 1px solid #e6e6e6; border-radius: 10px; }
    .decoded-message { font-size: 16px; font-weight: 700; color: var(--accent); background: #f0f8ff; padding: 1em; border-radius: 10px; border: 2px solid var(--accent); white-space: pre-wrap; }
    .debug-info { font-size: 12px; color: #444; background: #fafafa; padding: 1em; border-radius: 10px; white-space: pre-wrap; }
    #closeBtn { margin-top: 0.5em; padding: 0.6em 1.2em; border: none; border-radius: 10px; background: #050505; color: white; cursor: pointer; }
  </style>
</head>
<body>

  <div id="header">
    <div id="title">Binary Whisper Decoder — <strong>CellNumber</strong></div>
    <div id="controls">
      <label class="pill">Cells/linha: <input id="cellNumber" type="number" min="2" max="200" value="20"></label>
      <label class="pill">Inner ratio: <input id="innerRatio" type="range" min="0.5" max="0.95" step="0.01" value="0.80"><span id="innerRatioVal">0.80</span></label>
      <label class="pill">Threshold bias: <input id="thrBias" type="range" min="-60" max="60" step="1" value="0"><span id="thrBiasVal">0</span></label>
      <label class="pill">Ordem: 
        <select id="order">
          <option value="row">Row-major</option>
          <option value="col">Col-major</option>
          <option value="auto" selected>Auto</option>
        </select>
      </label>
      <label class="pill">Offset bits: <input id="bitOffset" type="number" min="0" max="7" value="0"></label>
      <button id="decode" class="pill btn" title="Decodificar">Decode</button>
      <button id="rerun" class="pill btn" title="Rerun on last image">Rerun</button>
    </div>
  </div>

  <div id="dropzone">drop your whisper here</div>
  <canvas id="canvas"></canvas>

  <div id="modal">
    <div id="modalContent">
      <div class="result-section">
        <h3>Decoded Message:</h3>
        <div id="decodedText" class="decoded-message"></div>
      </div>
      <div class="result-section debug-info">
        <h4>Debug Info:</h4>
        <div id="debugInfo"></div>
      </div>
      <button id="closeBtn">close</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const dropzone = document.getElementById("dropzone");
    const modal = document.getElementById("modal");
    const decodedTextDiv = document.getElementById("decodedText");
    const debugInfo = document.getElementById("debugInfo");
    const closeBtn = document.getElementById("closeBtn");

    const cellNumberInput = document.getElementById('cellNumber');
    const innerRatioInput = document.getElementById('innerRatio');
    const innerRatioVal = document.getElementById('innerRatioVal');
    const thrBiasInput = document.getElementById('thrBias');
    const thrBiasVal = document.getElementById('thrBiasVal');
    const orderSelect = document.getElementById('order');
    const bitOffsetInput = document.getElementById('bitOffset');
    const decodeBtn = document.getElementById('decode');
    const rerunBtn = document.getElementById('rerun');

    let lastImageDataURL = null;

    innerRatioInput.addEventListener('input', () => innerRatioVal.textContent = Number(innerRatioInput.value).toFixed(2));
    thrBiasInput.addEventListener('input', () => thrBiasVal.textContent = String(thrBiasInput.value));

    ["dragenter","dragover","dragleave","drop"].forEach(name => {
      document.addEventListener(name, e => e.preventDefault(), false);
    });

    dropzone.addEventListener("dragover", e => { e.preventDefault(); e.stopPropagation(); dropzone.style.background = "#333"; });
    dropzone.addEventListener("dragleave", e => { e.preventDefault(); e.stopPropagation(); dropzone.style.background = "#050505"; });
    dropzone.addEventListener("drop", e => {
      e.preventDefault(); e.stopPropagation(); dropzone.style.background = "#050505"; handleFile(e.dataTransfer.files[0]);
    });
    dropzone.addEventListener("click", () => {
      const input = document.createElement("input"); input.type = "file"; input.accept = "image/*";
      input.onchange = e => handleFile(e.target.files[0]); input.click();
    });

    rerunBtn.addEventListener('click', () => {
      if (!lastImageDataURL) return;
      const img = new Image();
      img.onload = function() { canvas.width = this.width; canvas.height = this.height; ctx.drawImage(this, 0, 0); setTimeout(decodeGrid, 50); };
      img.src = lastImageDataURL;
    });
    decodeBtn.addEventListener('click', () => { if (lastImageDataURL) decodeGrid(); });

    function handleFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0);
          lastImageDataURL = e.target.result; decodeGrid();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function decodeGrid() {
      try {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const { data, width, height } = imageData;

        const n = parseInt(cellNumberInput.value);
        const innerRatio = parseFloat(innerRatioInput.value);
        const bitOffsetUI = parseInt(bitOffsetInput.value) || 0;
        const orderUI = orderSelect.value;

        const stats = globalBrightnessStats(data, width, height);
        const baseThr = stats.mean + Number(thrBiasInput.value);
        const darkThr = clamp(baseThr, 60, 230);
        const lightThr = clamp(baseThr, 60, 230);

        const imgSize = Math.min(width, height);
        const cellSize = imgSize / n;

        const modes = ['dark','light'];
        const orders = orderUI === 'auto' ? ['row','col'] : [orderUI];

        let best = null;

        for (const mode of modes) {
          const bitsRow = [];
          const bitsCol = [];

          for (let r = 0; r < n; r++) {
            for (let c = 0; c < n; c++) {
              const filled = sampleCellBySquare(data, width, height, r, c, cellSize, innerRatio, darkThr, lightThr, mode);
              const bit = filled ? '1' : '0';
              bitsRow.push(bit);
              bitsCol[c * n + r] = bit;
            }
          }

          const bitstreams = [];
          if (orders.includes('row')) bitstreams.push({ order: 'row', bits: bitsRow.join('') });
          if (orders.includes('col')) bitstreams.push({ order: 'col', bits: bitsCol.join('') });

          for (const { order, bits } of bitstreams) {
            for (let offset = 0; offset < 8; offset++) {
              if (orderUI !== 'auto' && offset !== bitOffsetUI) continue;
              const { text, score, printableRatio, stoppedAtNull } = bitsToAscii(bits, offset);
              const fillRatio = (bits.match(/1/g) || []).length / bits.length;
              const candidate = { text, score, printableRatio, stoppedAtNull, mode, order, offset, fillRatio };
              if (!best || candidate.score > best.score) best = candidate;
            }
          }
        }

        let debug = `Image: ${width}x${height}\n` +
                    `Cells/linha: ${n}\nCell size: ${cellSize.toFixed(2)} px\n` +
                    `Inner ratio: ${innerRatio.toFixed(2)}\n` +
                    `Global mean: ${stats.mean.toFixed(1)}  std: ${stats.std.toFixed(1)}  median: ${stats.median.toFixed(1)}\n` +
                    `Threshold base: ${baseThr.toFixed(1)} (bias ${thrBiasInput.value})\n`;

        if (best && best.text) {
          debug += `\nChosen -> mode: ${best.mode} | order: ${best.order} | bit offset: ${best.offset}\n` +
                   `Fill ratio: ${(best.fillRatio*100).toFixed(1)}% | Printable: ${(best.printableRatio*100).toFixed(1)}% | Score: ${best.score}\n` +
                   (best.stoppedAtNull ? `Stopped at NULL (0x00)\n` : '') +
                   `Tip: adjust Threshold bias or Offset if the text looks wrong.`;
          showResult(best.text, debug);
        } else {
          debug += `\nNo valid result. Try different Cells/linha, Inner ratio, Threshold bias.`;
          showResult('[Could not decode]', debug);
        }
      } catch (err) {
        showResult('[Decoding error]', String(err?.message || err));
      }
    }

    function globalBrightnessStats(data, w, h) {
      let sum = 0, sum2 = 0; const vals = [];
      const step = Math.max(3, Math.floor(Math.min(w, h) / 200));
      for (let y = 0; y < h; y += step) {
        let base = (y * w) * 4;
        for (let x = 0; x < w; x += step) {
          const i = base + x * 4; const r = data[i], g = data[i+1], b = data[i+2];
          const v = (r + g + b) / 3; sum += v; sum2 += v*v; vals.push(v);
        }
      }
      const n = vals.length; const mean = sum / n; const std = Math.sqrt(Math.max(0, sum2/n - mean*mean));
      vals.sort((a,b)=>a-b); const median = vals[Math.floor(n/2)] || mean;
      return { mean, std, median };
    }

    function sampleCellBySquare(data, w, h, row, col, cellSize, innerRatio, darkThr, lightThr, mode) {
      const px0 = Math.floor(col * cellSize);
      const py0 = Math.floor(row * cellSize);
      const inner = cellSize * innerRatio;
      const margin = (cellSize - inner) / 2;
      const sx = Math.max(0, Math.floor(px0 + margin));
      const sy = Math.max(0, Math.floor(py0 + margin));
      const ex = Math.min(w - 1, Math.floor(px0 + cellSize - margin));
      const ey = Math.min(h - 1, Math.floor(py0 + cellSize - margin));

      const stride = Math.max(1, Math.floor(inner / 8));
      let darkVotes = 0, lightVotes = 0, total = 0;
      for (let y = sy; y <= ey; y += stride) {
        for (let x = sx; x <= ex; x += stride) {
          const idx = (y * w + x) * 4;
          const r = data[idx], g = data[idx+1], b = data[idx+2];
          const br = (r + g + b) / 3; total++;
          if (br < darkThr) darkVotes++;
          if (br > lightThr) lightVotes++;
        }
      }
      if (mode === 'dark') return darkVotes >= total/2;
      return lightVotes >= total/2;
    }

    function bitsToAscii(bits, offset) {
      let text = ""; let printable = 0; let total = 0; let stoppedAtNull = false;
      const L = bits.length - (bits.length % 8);
      for (let i = offset; i + 8 <= L; i += 8) {
        const byte = bits.slice(i, i + 8);
        const code = parseInt(byte, 2);
        total++;
        if (code === 0) { stoppedAtNull = true; break; }
        if ((code >= 32 && code <= 126) || code === 9 || code === 10 || code === 13) {
          text += String.fromCharCode(code); printable++;
        } else {
          text += "·";
        }
      }
      const printableRatio = total ? printable / total : 0;
      const spaceCount = (text.match(/\\s/g) || []).length;
      const alphaCount = (text.match(/[A-Za-z]/g) || []).length;
      const score = printable * 4 + spaceCount * 2 + alphaCount * 1.5 + (text.length >= 8 ? 5 : 0);
      return { text: text.trim(), score, printableRatio, length: total, stoppedAtNull };
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function showResult(text, debug) {
      decodedTextDiv.textContent = text;
      debugInfo.textContent = debug;
      modal.style.display = "flex";
    }

    closeBtn.addEventListener("click", () => { modal.style.display = "none"; });
    modal.addEventListener("click", e => { if (e.target === modal) modal.style.display = "none"; });
  </script>
</body>
</html>
