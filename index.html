<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Binary Whisper Decoder</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: white;
    background-image: 
      linear-gradient(to right, #050505 1px, transparent 1px),
      linear-gradient(to bottom, #050505 1px, transparent 1px);
    background-size: 40px 40px;
    font-family: monospace;
  }
  
  #status {
    margin-bottom: 20px;
    padding: 10px 20px;
    background: #f0f0f0;
    border-radius: 5px;
    font-size: 14px;
  }
  
  #dropzone {
    background: #050505;
    color: white;
    padding: 1.2em 3em;
    border-radius: 2em;
    font-size: 1.2em;
    cursor: pointer;
    transition: background 0.3s;
  }
  
  #dropzone:hover { background: #222; }
  #dropzone.disabled { 
    background: #666; 
    cursor: not-allowed; 
  }
  
  #canvas { display: none; }
  
  #modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
  }
  
  #modalContent {
    background: #fff;
    color: #050505;
    padding: 2em;
    border-radius: 1em;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    font-family: monospace;
    white-space: pre-wrap;
    text-align: left;
  }
  
  #closeBtn {
    margin-top: 1em;
    padding: 0.5em 1.5em;
    border: none;
    border-radius: 0.5em;
    background: #050505;
    color: white;
    font-family: monospace;
    cursor: pointer;
  }
  
  .debug-info {
    font-size: 12px;
    color: #666;
    margin-top: 10px;
  }
</style>
</head>
<body>

<div id="status">Loading OpenCV.js...</div>
<div id="dropzone" class="disabled">drop your whisper here</div>
<canvas id="canvas"></canvas>

<div id="modal">
  <div id="modalContent">
    <div id="decodedText"></div>
    <div id="debugInfo" class="debug-info"></div>
    <button id="closeBtn">close</button>
  </div>
</div>

<script>
let cvReady = false;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const dropzone = document.getElementById("dropzone");
const modal = document.getElementById("modal");
const decodedTextDiv = document.getElementById("decodedText");
const debugInfo = document.getElementById("debugInfo");
const closeBtn = document.getElementById("closeBtn");
const status = document.getElementById("status");

// Wait for OpenCV to load
function onOpenCvReady() {
  cvReady = true;
  status.textContent = "Ready to decode whispers!";
  dropzone.classList.remove("disabled");
  console.log("OpenCV.js loaded successfully");
}

// Check if OpenCV is already loaded, otherwise wait
if (typeof cv !== 'undefined') {
  onOpenCvReady();
} else {
  // Set up the callback for when OpenCV loads
  window.Module = {
    onRuntimeInitialized: onOpenCvReady
  };
}

// Prevent browser from hijacking drops
["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
  document.addEventListener(eventName, e => e.preventDefault(), false);
});

// Dropzone events
dropzone.addEventListener("dragover", e => {
  e.preventDefault();
  e.stopPropagation();
  if (cvReady) dropzone.style.background = "#333";
});

dropzone.addEventListener("dragleave", e => {
  e.preventDefault();
  e.stopPropagation();
  dropzone.style.background = "#050505";
});

dropzone.addEventListener("drop", e => {
  e.preventDefault();
  e.stopPropagation();
  dropzone.style.background = "#050505";
  if (cvReady) handleFile(e.dataTransfer.files[0]);
});

dropzone.addEventListener("click", () => {
  if (!cvReady) return;
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "image/*";
  input.onchange = e => handleFile(e.target.files[0]);
  input.click();
});

function handleFile(file) {
  if (!file || !cvReady) return;
  
  status.textContent = "Processing image...";
  
  const img = new Image();
  img.onload = () => {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    setTimeout(() => {
      try {
        decodeImage();
      } catch (error) {
        console.error("Decoding error:", error);
        showResult("[Error during decoding: " + error.message + "]", "");
      }
    }, 100);
  };
  
  img.onerror = () => {
    status.textContent = "Error loading image";
  };
  
  img.src = URL.createObjectURL(file);
}

function decodeImage() {
  let src = cv.imread(canvas);
  let gray = new cv.Mat();
  
  try {
    // Convert to grayscale
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
    
    // Apply slight blur to reduce noise
    cv.medianBlur(gray, gray, 3);
    
    // Detect circles with more relaxed parameters
    let circles = new cv.Mat();
    cv.HoughCircles(
      gray, circles, cv.HOUGH_GRADIENT, 
      1,     // dp
      15,    // minDist (reduced from 20)
      80,    // param1 (reduced from 100)
      25,    // param2 (reduced from 30)
      5,     // minRadius (reduced from 10)
      100    // maxRadius (increased from 60)
    );
    
    let debugText = `Image size: ${canvas.width}x${canvas.height}\n`;
    debugText += `Circles detected: ${circles.cols}\n`;
    
    if (circles.cols === 0) {
      showResult("[No circles detected - try adjusting the image contrast]", debugText);
      return;
    }
    
    // Extract circle data
    let circleData = [];
    for (let i = 0; i < circles.cols; i++) {
      let x = Math.round(circles.data32F[i * 3]);
      let y = Math.round(circles.data32F[i * 3 + 1]);
      let r = Math.round(circles.data32F[i * 3 + 2]);
      
      // Create mask for this circle
      let mask = cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8UC1);
      cv.circle(mask, new cv.Point(x, y), Math.max(r-2, 1), new cv.Scalar(255), -1);
      
      // Calculate mean brightness inside circle
      let mean = cv.mean(gray, mask)[0];
      let bit = (mean < 128) ? "1" : "0";
      
      circleData.push({x, y, r, mean: Math.round(mean), bit});
      mask.delete();
    }
    
    // Sort circles: top to bottom, then left to right
    circleData.sort((a, b) => {
      const rowTolerance = 20; // pixels tolerance for same row
      if (Math.abs(a.y - b.y) > rowTolerance) {
        return a.y - b.y;
      }
      return a.x - b.x;
    });
    
    // Build binary string
    let binaryString = circleData.map(c => c.bit).join("");
    debugText += `Binary length: ${binaryString.length}\n`;
    debugText += `Binary: ${binaryString}\n\n`;
    
    // Convert binary to text
    let text = "";
    let validBytes = 0;
    for (let i = 0; i < binaryString.length; i += 8) {
      let byte = binaryString.substr(i, 8);
      if (byte.length === 8) {
        let charCode = parseInt(byte, 2);
        if (charCode >= 32 && charCode <= 126) { // printable ASCII
          text += String.fromCharCode(charCode);
          validBytes++;
        } else if (charCode === 10 || charCode === 13) { // newlines
          text += String.fromCharCode(charCode);
          validBytes++;
        } else {
          text += "ï¿½"; // replacement character for invalid bytes
        }
      }
    }
    
    debugText += `Valid bytes decoded: ${validBytes}\n`;
    debugText += `Circle details:\n`;
    circleData.forEach((c, i) => {
      debugText += `${i+1}: (${c.x},${c.y}) r=${c.r} mean=${c.mean} bit=${c.bit}\n`;
    });
    
    showResult(text || "[Could not decode meaningful text]", debugText);
    
  } finally {
    // Clean up
    src.delete();
    gray.delete();
    if (typeof circles !== 'undefined') circles.delete();
    status.textContent = "Ready to decode whispers!";
  }
}

function showResult(text, debug) {
  decodedTextDiv.textContent = text;
  debugInfo.textContent = debug;
  modal.style.display = "flex";
}

closeBtn.addEventListener("click", () => {
  modal.style.display = "none";
});

// Handle window drops
window.addEventListener("dragover", e => e.preventDefault());
window.addEventListener("drop", e => e.preventDefault());
</script>

</body>
</html>
